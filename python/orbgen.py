import numpy as np

from scipy.special import spherical_jn
from scipy.linalg import eigvalsh_tridiagonal

import matplotlib.pyplot as plt

import subprocess

'''
Returns the first n roots of the l-th order spherical
Bessel function of the first kind.

Parameters
----------
    l : int
        Order of the spherical Bessel function.
    n : int
        Number of roots to be returned.

Returns
-------
    roots : array
        A 1-D array containing the first n roots of the l-th order spherical Bessel function.

References
----------
    Ikebe, Y., Kikuchi, Y., & Fujishiro, I. (1991).
    Computing zeros and orders of Bessel functions.
    Journal of Computational and Applied Mathematics, 38(1-3), 169-184.

'''
def spherical_jn_root(l, n):
    nu = l + 0.5
    sz = n*2 + l + 10

    alpha = nu + 2*np.arange(2, sz+1, dtype=int)

    A_diag = np.zeros(sz)
    A_diag[0] = 2. / ( (nu+3) * (nu+1) )
    A_diag[1:] = 2. / ( (alpha+1) * (alpha-1) )
    A_subdiag = 1. / ( (alpha-1) * np.sqrt(alpha*(alpha-2)) )

    eigval = eigvalsh_tridiagonal(A_diag, A_subdiag)[::-1]
    return 2. / np.sqrt(eigval[:n])


'''
Tail-smoothing function used in the generation of numerical radial functions.

References
----------
    Chen, M., Guo, G. C., & He, L. (2010).
    Systematically improvable optimized atomic basis sets for ab initio calculations.
    Journal of Physics: Condensed Matter, 22(44), 445501.

'''
def smoothing(r, rcut, sigma=0.1):
    if abs(sigma) < 1e-12:
        g = np.zeros_like(r)
        g[r < rcut] = 1.0
    else:
        g = 1. - np.exp(-0.5*((r-rcut)/sigma)**2)
        g[r >= rcut] = 0.0

    return g


'''
Writes an ABACUS orbital file header to a file object.

A typical header looks like

<<<<<<< starts here (taken from C_gga_8au_100Ry_2s2p1d.orb)
---------------------------------------------------------------------------
Element                     C
Energy Cutoff(Ry)          100
Radius Cutoff(a.u.)         8
Lmax                        2
Number of Sorbital-->       2
Number of Porbital-->       2
Number of Dorbital-->       1
---------------------------------------------------------------------------
SUMMARY  END

Mesh                        801
dr                          0.01
>>>>>>> ends here

Parameters
----------
    f : file object
        Must be opened in advance.
    elem : str
        Element symbol.
    ecut : int or float
        Energy cutoff. (To be studied...)
    rcut : int or float
        Cutoff radius.
    nzeta : list of int
        Number of orbitals for each angular momentum.
    lmax : int
        Maximum angular momentum.
    dr : float
        Grid spacing.

'''
def write_header(f, elem, ecut, rcut, nzeta, lmax, dr):

    assert(len(nzeta) == lmax+1)
    nr = int(rcut/dr) + 1
    symbol = ['S', 'P', 'D', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'O', 'Q', 'R', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']

    f.write('---------------------------------------------------------------------------\n')
    f.write('Element                     {0}\n'.format(elem))
    f.write('Energy Cutoff(Ry)           {0}\n'.format(ecut))
    f.write('Radius Cutoff(a.u.)         {0}\n'.format(rcut))
    f.write('Lmax                        {0}\n'.format(lmax))

    for l in range(lmax+1):
        f.write("Number of {0}orbital-->       {1}\n".format(symbol[l], nzeta[l]))

    f.write('---------------------------------------------------------------------------\n')
    f.write('SUMMARY  END\n')
    f.write('Mesh                        {0}\n'.format(nr))
    f.write('dr                          {0}\n'.format(dr))


'''
Writes a numerical radial function to a file object.

Parameters
----------
    f : file object
        Must be opened in advance.
    l : int
        Angular momentum.
    izeta : int
        Zeta number.

'''
def write_chi(f, l, izeta, chi):
    f.write('                Type                   L                   N\n')
    f.write('                   0                   {0}                   {1}\n'.format(l, izeta))
    for ir, chi_of_r in enumerate(chi):
        f.write('{: 21.12e}'.format(chi_of_r))
        if ir % 4 == 3:
            f.write('\n')
    f.write('\n')


'''
Generates a set of numerical radial functions by linear combinations of spherical Bessel functions.

Parameters
----------
    coeff : list of list of list of float
        A nested list containing the coefficients of spherical Bessel functions.
    q : list of list of list of float
        Wave numbers of each spherical Bessel component.

        An orbital of angular momentum "l" and zeta number "izeta" is generated by
            \sum_{iq} coeff[l][izeta][iq] * j_l(q[l][izeta][iq]*r) * smoothing(r, rcut, sigma)

    rcut : int or float
        Cutoff radius.
    dr : float
        Grid spacing.
    sigma : float
        Smoothing parameter.

Returns
-------
    chi : list of list of array of float
        A nested list containing the numerical radial functions.

'''
def radgen(coeff, q, rcut, dr=0.01, sigma=0.1): 
    lmax = len(coeff)-1
    nzeta = [len(coeff[l]) for l in range(lmax+1)]

    nr = int(rcut/dr) + 1
    r = dr * np.arange(nr)
    g = smoothing(r, rcut, sigma)

    chi = [[np.zeros(nr)] * nzeta[l] for l in range(lmax+1)]
    for l in range(lmax+1):
        for izeta in range(nzeta[l]):
            for iq in range(len(coeff[l][izeta])):
                chi[l][izeta] += coeff[l][izeta][iq] * spherical_jn(l, q[l][izeta][iq]*r) * g

    return chi


'''
Generates a numerical atomic orbital file in the ABACUS orbital file format.

Parameters
----------
    fname : str
        Name of the orbital file to be generated.
    elem : str
        Element symbol.
    rcut : float
        Cutoff radius of the orbital.
    coeff : list of list of list of float
        A nested list containing the coefficients of spherical Bessel functions.
    q : list of list of list of float
        Wave numbers of each spherical Bessel component.
    dr : float
        Grid spacing of the orbital.
    sigma : float

'''
def filegen(fname, elem, rcut, coeff, q, dr=0.01, sigma=0.1):
    lmax = len(coeff)-1
    nzeta = [len(coeff[l]) for l in range(lmax+1)]
    chi = radgen(coeff, q, rcut, dr, sigma)
    
    with open(fname, 'w') as f:
        write_header(f, elem, 100, rcut, nzeta, lmax, dr)
        for l in range(lmax+1):
            for izeta in range(nzeta[l]):
                write_chi(f, l, izeta, chi[l][izeta])


'''
Converts a 1D array of (spherical Bessel) coefficients into a nested list.

The 1D array is assumed to be a direct concatenation of spherical Bessel coefficients
for different orbitals. The nested list is a list of lists of lists, where the first
index is the angular momentum, the second index is the zeta number, and the third index
is the wave vector number.

This is the inverse of list2array.

Parameters
----------
    c : 1D array
        A 1D array containing the coefficients of spherical Bessel functions.
    lmax : int
        Maximum angular momentum.
    nzeta : list of int
        Number of orbitals for each angular momentum.
    nq : list of int
        Number of spherical Bessel wave numbers involved in each orbital.
'''
def array2list(c, lmax, nzeta, nq):
    assert(len(nzeta) == lmax+1)
    assert(np.sum(nq) == len(c))

    iq = np.insert(np.cumsum(nq), 0, 0)
    iz = np.insert(np.cumsum(nzeta), 0, 0)
    return [[c[iq[i]:iq[i+1]] for i in range(iz[l], iz[l+1])] for l in range(lmax+1)]


'''
Flattens a nested list of coefficients into a 1D array.

This is the inverse of array2list.
'''
def list2array(coeff):
    return np.array([clzq for cl in coeff for clz in cl for clzq in clz])


'''

'''
def read_siab(fname): 
    with open('ORBITAL_RESULTS.txt', 'r') as f:
        data = list(filter(None, re.split('\t| |\n', f.read())))

    delim = [i for i, x in enumerate(data) if x == 'Type' or x == '</Coefficient>']
    ll = [int(data[delim[i]+4]) for i in range(len(delim)-1)]
    lmax = max(ll)
    nzeta = [ll.count(l) for l in range(lmax+1)]
    
    nzeta_cumu = np.insert(np.cumsum(nzeta), 0, 0)
    iorb = lambda l, izeta : nzeta_cumu[l] + izeta
    return [[data[delim[iorb(l,izeta)]+6:delim[iorb(l,izeta)+1]] for izeta in range(nzeta[l])] for l in range(lmax+1)]


'''
Spherical Bessel coefficients to energy.

Given a set of spherical Bessel coefficients, this function generates an ABACUS orbital file
and calls ABACUS to run an SCF calculation to get the energy.

Parameters
----------
    c : 1D array
        A 1D array containing the coefficients of spherical Bessel functions.
    lmax : int
        Maximum angular momentum.
    nzeta : list of int
        Number of orbitals for each angular momentum.
    nq : int or list of int
        Number of spherical Bessel wave vectors involved in each orbital.
    fname : str
        Name of the orbital file to be generated.
    elem : str
        Element symbol.
    rcut : int or float
        Cutoff radius of the orbital.
    jobdir : str
        Directory to run the SCF calculation.
    nthreads : int
        Number of threads to be used in the SCF calculation.
    nprocs : int
        Number of MPI processes to be used in the SCF calculation.
'''
def c2e(c, lmax, nzeta, nq, fname, elem, rcut, jobdir, nthreads=2, nprocs=4):

    # generate orbital file
    filegen(fname, elem, rcut, array2list(c, lmax, nzeta, nq))

    # call ABACUS to run SCF
    subprocess.run("cd {jobdir}; " \
                   "OMP_NUM_THREADS={nthreads} mpirun -np {nprocs} /home/zuxin/abacus-develop/bin/abacus" \
                   .format(jobdir=jobdir, nthreads=nthreads, nprocs=nproc), \
                   shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    # read energy
    result = subprocess.run("grep '!FINAL' OUT.ABACUS/running_scf.log | awk '{print $2}'", \
                            shell=True, capture_output=True, text=True)

    return float(result.stdout)


########################################################################
#                               main
########################################################################

#coeff = read_siab('/home/zuxin/tmp/nao/yike/pd_04/49_In_DZP/info/10/ORBITAL_RESULTS.txt')



# initial guess of spherical Bessel coefficients
#c0 = list2array(read_siab(fname))



#print('original coeff = ', coeff)
#
#c = list2array(coeff)
#print(c)
#
#c2 = array2list(c, 2, [2,2,1], [2,2,3,6,1])
#print(c2)
#
#c3 = list2array(c2)
#print(c3)
#
#

#coeff = [[[1.0, 2.0], [3.0, 4.0]], \
#         [[5.0, 6.0, 7.0], [1,2,3,4,5,6]], \
#         [[1.0]]]
#
#q = [[[1.0, 2.0], [3.0, 4.0]], \
#         [[5.0, 6.0, 7.0], [1,2,3,4,5,6]], \
#         [[1.0]]]
#
#filegen('C.orb', 'C', 1, coeff, q)

#rcut = 6
#r = np.linspace(0, 2*rcut, 10000)
#f = gauss_smoothing(r, rcut, 0.0)

#plt.plot(r,f)
#plt.show()

