import re
from itertools import accumulate

'''
Writes an ABACUS orbital file header to a file object.

A typical header looks like

<<<<<<< starts here (taken from C_gga_8au_100Ry_2s2p1d.orb)
---------------------------------------------------------------------------
Element                     C
Energy Cutoff(Ry)          100
Radius Cutoff(a.u.)         8
Lmax                        2
Number of Sorbital-->       2
Number of Porbital-->       2
Number of Dorbital-->       1
---------------------------------------------------------------------------
SUMMARY  END

Mesh                        801
dr                          0.01
>>>>>>> ends here

Parameters
----------
    f : file object
        Must be opened in advance.
    elem : str
        Element symbol.
    ecut : int or float
        Energy cutoff. (To be studied...)
    rcut : int or float
        Cutoff radius.
    nzeta : list of int
        Number of orbitals for each angular momentum.
    lmax : int
        Maximum angular momentum.
    dr : float
        Grid spacing.

'''
def write_header(f, elem, ecut, rcut, nzeta, dr):

    lmax = len(nzeta)-1
    nr = int(rcut/dr) + 1
    symbol = ['S', 'P', 'D', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'O', 'Q', 'R', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']

    f.write('---------------------------------------------------------------------------\n')
    f.write('Element                     {0}\n'.format(elem))
    f.write('Energy Cutoff(Ry)           {0}\n'.format(ecut))
    f.write('Radius Cutoff(a.u.)         {0}\n'.format(rcut))
    f.write('Lmax                        {0}\n'.format(lmax))

    for l in range(lmax+1):
        f.write("Number of {0}orbital-->       {1}\n".format(symbol[l], nzeta[l]))

    f.write('---------------------------------------------------------------------------\n')
    f.write('SUMMARY  END\n\n')
    f.write('Mesh                        {0}\n'.format(nr))
    f.write('dr                          {0}\n'.format(dr))


'''
Writes a numerical radial function to a file object.

Parameters
----------
    f : file object
        Must be opened in advance.
    l : int
        Angular momentum.
    izeta : int
        Zeta number.
    chi : list of float
        Numerical radial function.

'''
def write_chi(f, l, izeta, chi):
    f.write('                Type                   L                   N\n')
    f.write('                   0                   {0}                   {1}\n'.format(l, izeta))
    for ir, chi_of_r in enumerate(chi):
        f.write('{: 21.12e}'.format(chi_of_r))
        if ir % 4 == 3 and ir != len(chi)-1:
            f.write('\n')
    f.write('\n')


'''
Generates a numerical atomic orbital file in the ABACUS format.

Parameters
----------
    fname : str
        Name of the orbital file to be generated.
    elem : str
        Element symbol.
    rcut : float
        Cutoff radius of the orbital.
    chi : list of list of list of float
        Numerical radial functions of orbitals.
    dr : float
        Grid spacing.

'''
def write_orbfile(fname, elem, rcut, chi, dr=0.01):
    lmax = len(chi)-1
    nzeta = [len(chi[l]) for l in range(lmax+1)]
    
    with open(fname, 'w') as f:
        write_header(f, elem, 100, rcut, nzeta, dr)
        for l in range(lmax+1):
            for izeta in range(nzeta[l]):
                write_chi(f, l, izeta, chi[l][izeta])


'''
Reads an ABACUS orbital file.
'''
def read_orbfile(fname):
    with open(fname, 'r') as f:
        data = list(filter(None, re.split('\t| |\n', f.read())))

    elem = data[data.index('Element')+1]
    ecut = float(data[data.index('Cutoff(Ry)')+1])
    rcut = float(data[data.index('Cutoff(a.u.)')+1])
    lmax = int(data[data.index('Lmax')+1])

    symbol = ['S', 'P', 'D', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'O', 'Q', 'R', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
    nzeta = [ int(data[data.index(symbol[l] + 'orbital-->') + 1]) for l in range(lmax+1) ]

    nr = int(data[data.index('Mesh')+1])
    dr = float(data[data.index('dr')+1])

    delim = [i for i, x in enumerate(data) if x == 'Type'] + [len(data)]
    nzeta_cumu = [0] + list(accumulate(nzeta))
    iorb = lambda l, izeta : nzeta_cumu[l] + izeta
    chi = [[ list(map(float, data[delim[iorb(l,izeta)]+6:delim[iorb(l,izeta)+1]] )) \
            for izeta in range(nzeta[l])] for l in range(lmax+1)]

    #print('elem = ', elem)
    #print('ecut = ', ecut)
    #print('rcut = ', rcut)
    #print('lmax = ', lmax)
    #print('nzeta = ', nzeta)
    #print('nr = ', nr)
    #print('dr = ', dr)
    #print(chi[0][0][:10])
    #print(chi[0][0])


'''
Reads coefficients generated by SIAB into a nested list.
'''
def read_coeff(fname):
    with open(fname, 'r') as f:
        data = list(filter(None, re.split('\t| |\n', f.read())))

    delim = [i for i, x in enumerate(data) if x == 'Type' or x == '</Coefficient>']
    ll = [int(data[delim[i]+4]) for i in range(len(delim)-1)]
    lmax = max(ll)
    nzeta = [ll.count(l) for l in range(lmax+1)]
    
    nzeta_cumu = [0] + list(accumulate(nzeta))
    iorb = lambda l, izeta : nzeta_cumu[l] + izeta
    return [[ list(map(float, data[delim[iorb(l,izeta)]+6:delim[iorb(l,izeta)+1]])) \
            for izeta in range(nzeta[l])] for l in range(lmax+1)]


'''
Writes a nested list of spherical Bessel coefficients to a file object
in a format like that of SIAB-generated ORBITAL_RESULTS.txt.
'''
def write_coeff(f, coeff, elem):
    n = sum([len(coeff[l]) for l in range(len(coeff))])
    f.write('<Coefficient>\n')
    f.write('{0} Total number of radial orbitals.\n'.format(n))
    for l in range(len(coeff)):
        for izeta in range(len(coeff[l])):
            f.write('Type   L   Zeta\n')
            f.write('{elem} {angmom}  {izeta}\n'.format(elem=elem, angmom=l, izeta=izeta))
            for i in range(len(coeff[l][izeta])):
                f.write('{: 21.14f}\n'.format(coeff[l][izeta][i]))

    f.write('</Coefficient>\n')

############################################################
#                       Testing
############################################################
def test_read_coeff():
    print('Testing read_coeff...')

    coeff = read_coeff('./testfiles/ORBITAL_RESULTS.txt')
    lmax = len(coeff)-1
    nzeta = [len(coeff[l]) for l in range(lmax+1)]
    nq = [len(coeff[l][izeta]) for l in range(lmax+1) for izeta in range(nzeta[l])]

    assert lmax == 3
    assert nzeta == [2, 2, 2, 1]
    assert nq == [31] * 7
    assert coeff[0][0][0] == 0.09780237320580
    assert coeff[0][0][30] == 0.00021711814077
    assert coeff[1][1][0] == -0.78111126700600
    assert coeff[3][0][30] == -0.09444436877182

    print('...Passed!')


def test_write_coeff():
    print('Testing write_coeff...')

    coeff = read_coeff('./testfiles/ORBITAL_RESULTS.txt')
    with open('./testfiles/ORBITAL_RESULTS.txt.copy', 'w') as f:
        write_coeff(f, coeff, 'Unknown')
    coeff2 = read_coeff('./testfiles/ORBITAL_RESULTS.txt.copy')
    assert coeff == coeff2

    print('...Passed!')


def test_write_orbfile():
    from jnroot import ikebe

    print('Testing write_orbfile...')

    rcut = 3.14
    chi = [[[0,0,0,1,2],[2,3,4,5]], [[6,7,8]], [], [[9,10]]]

    write_orbfile('./testfiles/Unknown.orb', 'Unknown', rcut, chi)

    # TODO should have a read_orbfile function to read file back and do further check

    print('...Passed!')


if __name__ == '__main__':
    test_read_coeff()
    test_write_coeff()
    test_write_orbfile()
    read_orbfile('./testfiles/C_gga_8au_100Ry_2s2p1d.orb')

    coeff =  [[[-0.22319273382936658, -0.1935692770353136, 0.011898484474316167, 0.11687347789973701, 0.12424724776710969, 0.082826751969036, 0.039426527485066025, 0.009350748438199118, -0.002711813172651745, -0.004928288984114024, -0.003067808241357446, -0.0010580361641553372, -0.0011439640018363016, -0.0002709781545847151, -0.001356846431694946, 0.0002785320787625634, -0.0012951057606575107, 0.000823205142996889, -0.001533729202231069, 0.0013267383747682941, -0.002243739821384359, 0.0028827686740655204]], [[0.31489881082247795, 0.23032926246318386, 0.07452029206069405, -0.011082935875728539, -0.040694592814021574, -0.03391193894336489, -0.019691111499707623, -0.005795739729858165, -0.0010559715835145814, 0.00021013426442062743, -0.0010804442170462983, -0.0018444567909232613, -0.0011416021931900022, -0.0013896905727685176, 0.00010567313703063635, -0.0013384021875936208, 0.0005445377048263758, -0.0017427974121259394, 0.0013164127584227412, -0.0024294995719134653, 0.0026845260388395496, -0.00962980040832163]], [[-0.07724511065901557, -0.24018330937918517, -0.41667348834272955, -0.5612345764271982, -0.6432834945639484, -0.6561132968855918, -0.5986469171723564, -0.49224502020309474, -0.36042136532934477, -0.23269166151240536, -0.12882682275958157, -0.058179644745669806, -0.019879759662448166, -0.0032359945413300128, 3.9697296477234794e-05, 0.0006239628995839741, -0.0009135870763134326, 0.00031130486079140147, -0.00047062473024814613, 0.0012295324888643904, -0.00012199965090200087, -0.003022552040389695]]]
    write_coeff(open('./testfiles/In_sg15v1.0_7au_1s1p1d.coeff.txt', 'w'), coeff, 'In')

